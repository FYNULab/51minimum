C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE _肝泼__胨_
OBJECT MODULE PLACED IN 指纹密码锁.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE 指纹密码锁.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include"24C0x.h"
   4          #include"LCD12864.h"
   5          #define uchar unsigned char
   6          #define uint unsigned int
   7           
   8          #define buffer1ID  0x01
   9          #define buffer2ID  0x02
  10          #define queren  0x88
  11          #define tuichu  0x85
  12          #define shanchu 0x82
  13          
  14          #define User 1                               
  15          
  16          void fan();
  17                  
  18          sbit B0=B^0;
  19          sbit B7=B^7;
  20          sbit k2=P3^7;
  21          /*sbit ks1=P2^2;
  22          sbit ks2=P2^3;
  23          sbit ks3=P2^4;
  24          sbit ks4=P2^5;
  25          sbit ks5=P2^6;
  26          sbit ks6=P2^7;
  27          sbit ks7=P0^0;
  28          sbit ks8=P0^1;
  29          sbit ks9=P0^3;
  30          sbit ks10=P0^7;*/
  31          sbit jidianqi=P3^6;
  32          
  33                  
  34          extern unsigned char times[];
  35          uchar  Member=0,sec;
  36          
  37          uchar  code buffer[User][6]=
  38          {
  39           {"000000"}
  40          };
  41                  
  42                  
  43          uchar dz[4];
  44          uchar time[4];                   
  45          uchar mima[6];
  46          uchar mimag[6];
  47          uchar mimaID[6]={1,2,3,4,5,6};
  48          
  49          
  50          uchar Address1=20,tempx=20; 
  51          uchar Address2=20;   
  52                  
  53          uchar data K;
  54          uchar data Key;
  55                  
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 2   

  56          uint PageID;
  57          uchar data querenma=11;
  58          uchar sum[2];
  59          int summaf,summas;
  60          
  61          uchar  xdata UserPassword[7]={0};//密码
  62          uchar  xdata DSY_BUFFER[16] ={0};//缓存
  63          
  64          
  65          void Red_Init(void);
  66          
  67          //检测脉冲宽度
  68          unsigned char check(void);
  69          
  70          unsigned char redchange(unsigned char rednum);
  71                  
  72          
  73          void delayms(unsigned int z)
  74          {
  75   1              unsigned int x,y;
  76   1              for(x=z;x>0;x--)
  77   1                      for(y=110;y>0;y--);
  78   1      }
  79          
  80          /********************************************************************
  81          * 名称 : Chack(uchar User_Number)
  82          * 功能 : 单一用户密码检测
  83          * 输入 : User_Number
  84          * 输出 : 密码正确与错误，错误返回0，正确返回1
  85          ********************************************************************/
  86          uchar Chack(uchar User_Number)
  87          {
  88   1              uchar flag, i,temp[6],Address;
  89   1              Address=User_Number*10;
  90   1              for(i=0;i<6;i++)
  91   1              {
  92   2                      temp[i]=x24c02_read(Address);
  93   2                      delayms(10);
  94   2                      Address++;
  95   2              }
  96   1              for(i=0;i<6;i++)
  97   1              {
  98   2                      if(temp[i]==UserPassword[i])
  99   2                              flag=1;
 100   2                      else    
 101   2                              flag=0;         
 102   2              }
 103   1                      return flag;
 104   1      }
 105          
 106          /********************************************************************
 107          * 名称 : PassWord_Chack()
 108          * 功能 : 所有用户密码检测
 109          * 输入 : 无
 110          * 输出 : 密码正确与错误，错误返回0，正确返回1
 111          ********************************************************************/
 112          uchar PassWord_Chack()
 113          {
 114   1              uchar i=0;
 115   1              while(i<User)
 116   1              {
 117   2                      if(Chack(i)==2)
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 3   

 118   2                      {
 119   3                              Member=i+2;
 120   3                              return 1;
 121   3                      }
 122   2                      i++;    
 123   2              }
 124   1              return 0;       
 125   1      }
 126             
 127          void delay(uint tt)
 128          {  uchar i;
 129   1         while(tt--)
 130   1         {
 131   2         for(i=0;i<125;i++);
 132   2         }
 133   1      }
 134          /********************************************************************
 135          * 名称 : UART_Init()
 136          * 功能 : 单片机串口初始化
 137          * 单片机：晶振11.0592MHz 波特率为9600bps
 138          * 指纹模块：波特率为9600bps，
 139          ********************************************************************/        
 140          void UART_Init()
 141          {
 142   1              SCON= 0x50;               //串口方式1   //REN=1; 允许接收
 143   1              PCON=0x01;                //SMOD=0
 144   1              TMOD= 0x01;               //定时器1定时方式2
 145   1              TH1= 0xFD;                //11.0592MHz  模块默认波特率为9600bps
 146   1              TL1= 0xFD;                                                                               
 147   1              TR0= 1;                   //启动定时器 
 148   1              EA=1;       
 149   1      }
 150              
 151          unsigned char Keycan(void) //按键扫描程序 P1.0--P1.3为行线 P1.4--P1.7为列线
 152          {
 153   1              unsigned char rcode, ccode;
 154   1              P1 = 0xF0;      // 发全0行扫描码，列线输入
 155   1              if((P1&0xF0) != 0xF0) // 若有键按下
 156   1              {
 157   2                      delay(1);// 延时去抖动 
 158   2                      if((P1&0xF0) != 0xF0)
 159   2                      {  
 160   3                              rcode = 0xef;         // 逐行扫描初值
 161   3                              while((rcode&0x10) != 0)
 162   3                              {
 163   4                                      P1 = rcode;         // 输出行扫描码
 164   4                                      if((P1&0xF0) != 0xF0) // 本行有键按下
 165   4                                      {
 166   5                                              ccode = (P1&0xF0)|0x0F;
 167   5                                              //do{;}
 168   5                                              while((P1&0xF0) != 0xF0); //等待键释放
 169   5                                              return ((~rcode) + (~ccode)); // 返回键编码
 170   5                                      }
 171   4                                      else
 172   4                                      rcode = (rcode<<1)|0x01; // 行扫描码左移一位
 173   4                              }
 174   3                      }
 175   2              }  
 176   1              return 0; // 无键按下，返回值为0
 177   1      }
 178                  
 179          void KeyDeal(unsigned char Key)
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 4   

 180          {  //unsigned char n;
 181   1         if(Key!=0)
 182   1       {
 183   2                         switch(Key)
 184   2                         {
 185   3                         case 0x12: K=1; break;        
 186   3                         case 0x22: K=2; break;  
 187   3                         case 0x42: K=3; break;  
 188   3                         case 0x82: break;       
 189   3                         case 0x13: K=4; break;
 190   3                         case 0x23: K=5; break;
 191   3                         case 0x43: K=6; break;
 192   3                         case 0x83: K=34;break;               
 193   3                         case 0x14: K=7; break;
 194   3                         case 0x24: K=8; break;
 195   3                         case 0x44: K=9; break;
 196   3                         case 0x84: break;            
 197   3                         case 0x18: break;            
 198   3                         case 0x28: K=0; break;
 199   3                         case 0x48: K=11; break;
 200   3                         case 0x88: break;            
 201   3                         default: break;
 202   3                         }
 203   2        }
 204   1      }
 205                  
 206               
 207                  
 208          //*************************************//
 209          void SFG_GetEcho()                            //握手
 210          {
 211   1         uchar i;
 212   1         SBUF=0xef;
 213   1         while(TI==0);
 214   1         TI=0;
 215   1         SBUF=0X01;
 216   1         while(TI==0);
 217   1         TI=0;
 218   1              
 219   1         SBUF=0XFF;
 220   1         while(TI==0);
 221   1         TI=0;
 222   1         SBUF=0XFF;
 223   1         while(TI==0);
 224   1         TI=0;
 225   1         SBUF=0XFF;
 226   1         while(TI==0);
 227   1         TI=0;
 228   1         SBUF=0XFF;
 229   1         while(TI==0);
 230   1         TI=0;
 231   1              
 232   1         SBUF=0X01;
 233   1         while(TI==0);
 234   1         TI=0;
 235   1              
 236   1         SBUF=0X00;
 237   1         while(TI==0);
 238   1         TI=0;
 239   1         SBUF=0X03;
 240   1         while(TI==0);
 241   1         TI=0;
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 5   

 242   1              
 243   1         SBUF=0X53;
 244   1         while(TI==0);
 245   1         TI=0;
 246   1               
 247   1         SBUF=0X00;
 248   1         while(TI==0);
 249   1         TI=0;
 250   1         summaf=0x57;
 251   1         SBUF=summaf;
 252   1         while(TI==0);
 253   1         TI=0;
 254   1              
 255   1         for(i=0;i<9;i++)
 256   1         {
 257   2          while(RI==0);
 258   2          RI=0;}
 259   1              
 260   1         while(RI==0);
 261   1         RI=0;
 262   1         querenma=SBUF;
 263   1         while(RI==0);
 264   1         RI=0;
 265   1         sum[1]=SBUF;
 266   1         while(RI==0);
 267   1         RI=0;
 268   1         sum[0]=SBUF;
 269   1         summas=(sum[1]<<8)+sum[0];                                                                    
 270   1      }
 271           
 272                  
 273          //***************************************//
 274                  
 275          void SFG_getimage()                           //录入指纹图像
 276          {
 277   1         uchar i;
 278   1         SBUF=0xef;
 279   1         while(TI==0);
 280   1         TI=0;
 281   1         SBUF=0X01;
 282   1         while(TI==0);
 283   1         TI=0;
 284   1              
 285   1         SBUF=0XFF;
 286   1         while(TI==0);
 287   1         TI=0;
 288   1         SBUF=0XFF;
 289   1         while(TI==0);
 290   1         TI=0;
 291   1         SBUF=0XFF;
 292   1         while(TI==0);
 293   1         TI=0;
 294   1         SBUF=0XFF;
 295   1         while(TI==0);
 296   1         TI=0;
 297   1              
 298   1         SBUF=0X01;
 299   1         while(TI==0);
 300   1         TI=0;
 301   1              
 302   1         SBUF=0X00;
 303   1         while(TI==0);
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 6   

 304   1         TI=0;
 305   1         SBUF=0X03;
 306   1         while(TI==0);
 307   1         TI=0;
 308   1              
 309   1         SBUF=0X01;
 310   1         while(TI==0);
 311   1         TI=0;
 312   1              
 313   1         SBUF=0X00;
 314   1         while(TI==0);
 315   1         TI=0;
 316   1         summaf=0x05;
 317   1         SBUF=summaf;
 318   1         while(TI==0);
 319   1         TI=0;
 320   1              
 321   1         for(i=0;i<9;i++)
 322   1         {
 323   2          while(RI==0);
 324   2          RI=0;}
 325   1              
 326   1         while(RI==0);
 327   1         RI=0;
 328   1         querenma=SBUF;
 329   1         while(RI==0);
 330   1         RI=0;
 331   1         sum[1]=SBUF;
 332   1         while(RI==0);
 333   1         RI=0;
 334   1         sum[0]=SBUF;
 335   1         summas=(sum[1]<<8)+sum[0];                                                                    
 336   1      }
 337                  
 338          void SFG_genchar(uchar bufferID) //生成特征并存于charbuffer1/2  调用后单片机波特率变化@@@
 339          {
 340   1         uchar i;
 341   1         SBUF=0xef;
 342   1         while(TI==0);
 343   1         TI=0;
 344   1         SBUF=0X01;
 345   1         while(TI==0);
 346   1         TI=0;
 347   1              
 348   1         SBUF=0XFF;
 349   1         while(TI==0);
 350   1         TI=0;
 351   1         SBUF=0XFF;
 352   1         while(TI==0);
 353   1         TI=0;
 354   1         SBUF=0XFF;
 355   1         while(TI==0);
 356   1         TI=0;
 357   1         SBUF=0XFF;
 358   1         while(TI==0);
 359   1         TI=0;
 360   1              
 361   1         SBUF=0X01;
 362   1         while(TI==0);
 363   1         TI=0;
 364   1              
 365   1         SBUF=0X00;
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 7   

 366   1         while(TI==0);
 367   1         TI=0;
 368   1         SBUF=0X04;
 369   1         while(TI==0);
 370   1         TI=0;
 371   1              
 372   1         SBUF=0X02;
 373   1         while(TI==0);
 374   1         TI=0;
 375   1              
 376   1         SBUF=bufferID;
 377   1         while(TI==0);
 378   1         TI=0;
 379   1              
 380   1         summaf=0x07+bufferID;
 381   1         sum[0]=summaf;
 382   1         sum[1]=summaf>>8;
 383   1         SBUF=sum[1];
 384   1         while(TI==0)
 385   1         TI=0;
 386   1         SBUF=sum[0];
 387   1         while(TI==0)
 388   1         TI=0;
 389   1              
 390   1         for(i=0;i<9;i++)
 391   1         {
 392   2          while(RI==0);
 393   2          RI=0;}
 394   1         while(RI==0);
 395   1         RI=0;
 396   1         querenma=SBUF;
 397   1         while(RI==0);
 398   1         RI=0;
 399   1         sum[1]=SBUF;
 400   1         while(RI==0);
 401   1         RI=0;
 402   1         sum[0]=SBUF;
 403   1         summas=(sum[1]<<8)+sum[0];                                                                    
 404   1      }
 405          
 406          void SFG_fastsearch(uchar bufferID)  //搜索指纹返回指纹ID号   sum、pagenum>255都会使程序卡@@@
 407          {
 408   1         uchar i,ID1,ID2;
 409   1         SBUF=0xef;
 410   1         while(TI==0);
 411   1         TI=0;
 412   1         SBUF=0X01;
 413   1         while(TI==0);
 414   1         TI=0;
 415   1         SBUF=0XFF;
 416   1         while(TI==0);
 417   1         TI=0;
 418   1         SBUF=0XFF;
 419   1         while(TI==0);
 420   1         TI=0;
 421   1         SBUF=0XFF;
 422   1         while(TI==0);
 423   1         TI=0;
 424   1         SBUF=0XFF;
 425   1         while(TI==0);
 426   1         TI=0;
 427   1              
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 8   

 428   1         SBUF=0X01;
 429   1         while(TI==0);
 430   1         TI=0;
 431   1              
 432   1         SBUF=0X00;
 433   1         while(TI==0);
 434   1         TI=0;
 435   1         SBUF=0X08;
 436   1         while(TI==0);
 437   1         TI=1;
 438   1              
 439   1         SBUF=0X1b;
 440   1         while(TI==0);
 441   1         TI=0;
 442   1              
 443   1         SBUF=bufferID;
 444   1         while(TI==0);
 445   1         TI=0;
 446   1              
 447   1         SBUF=0X00;
 448   1         while(TI==0);
 449   1         TI=0;
 450   1         SBUF=0;
 451   1         while(TI==0);
 452   1         TI=0;
 453   1              
 454   1         SBUF=0X00;
 455   1         while(TI==0);
 456   1         TI=0;
 457   1         SBUF=180;
 458   1         while(TI==0);
 459   1         TI=0;
 460   1              
 461   1         summaf=9+0x1b+bufferID+180;
 462   1         sum[0]=summaf;
 463   1         sum[1]=summaf>>8;
 464   1         SBUF=sum[1];
 465   1         while(TI==0);
 466   1         TI=1;
 467   1         SBUF=sum[0];
 468   1         while(TI==0);
 469   1         TI=0;
 470   1              
 471   1         for(i=0;i<9;i++)
 472   1         {
 473   2          while(RI==0);
 474   2          RI=0;}
 475   1                      
 476   1         while(RI==0);
 477   1         RI=0;
 478   1         querenma=SBUF;
 479   1              
 480   1         while(RI==0);
 481   1         RI=0;
 482   1         ID1=SBUF;
 483   1         while(RI==0);
 484   1         RI=0;
 485   1         ID2=SBUF;                              //接收到的ID号
 486   1         while(RI==0);
 487   1         RI=0;
 488   1         while(RI==0);
 489   1         RI=0;
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 9   

 490   1              
 491   1         while(RI==0);
 492   1         RI=0;
 493   1         sum[1]=SBUF;
 494   1         while(RI==0);
 495   1         RI=1;
 496   1         sum[0]=SBUF;
 497   1         summas=(sum[1]<<8)+sum[0];                                                                    
 498   1         //PageID=ID1;
 499   1         PageID=(ID1<<8)+ID2;
 500   1      }
 501                  
 502          void SFG_enroll()                                //自动注册模板返回存储ID  =录图像+合并生成模板+储存模板
 503          {
 504   1         uchar i,ID1,ID2;
 505   1         SBUF=0xef;
 506   1         while(TI==0);
 507   1         TI=1;
 508   1         SBUF=0X01;
 509   1         while(TI==0);
 510   1         TI=0;
 511   1              
 512   1         SBUF=0XFF;
 513   1         while(TI==0);
 514   1         TI=0;
 515   1         SBUF=0XFF;
 516   1         while(TI==0);
 517   1         TI=0;
 518   1         SBUF=0XFF;
 519   1         while(TI==0);
 520   1         TI=0;
 521   1         SBUF=0XFF;
 522   1         while(TI==0);
 523   1         TI=0;
 524   1              
 525   1         SBUF=0X01;
 526   1         while(TI==0);
 527   1         TI=0;
 528   1              
 529   1         SBUF=0X00;
 530   1         while(TI==0);
 531   1         TI=0;
 532   1         SBUF=0X03;
 533   1         while(TI==0);
 534   1         TI=0;
 535   1              
 536   1         SBUF=0X10;
 537   1         while(TI==0);
 538   1         TI=0;
 539   1                 
 540   1         SBUF=0X00;
 541   1         while(TI==0);
 542   1         TI=0;
 543   1         summaf=0x14;
 544   1         SBUF=summaf;    //校验和
 545   1         while(TI==0);
 546   1         TI=0;
 547   1              
 548   1         for(i=0;i<9;i++)
 549   1         {
 550   2          while(RI==0);
 551   2          RI=1;}
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 10  

 552   1         while(RI==0);
 553   1         RI=0;
 554   1         querenma=SBUF;
 555   1         while(RI==0);
 556   1         RI=0;
 557   1         ID1=SBUF;
 558   1         while(RI==0);
 559   1         RI=0;
 560   1         ID2=SBUF;
 561   1              
 562   1         while(RI==0);
 563   1         RI=0;
 564   1         sum[1]=SBUF;
 565   1         while(RI==0);
 566   1         RI=0;
 567   1         sum[0]=SBUF;
 568   1         summas=(sum[1]<<8)+sum[0];                                                                    
 569   1         //PageID=ID1;
 570   1         PageID=(ID1<<8)+ID2;
 571   1      }
 572          void SFG_deletchar(uint pageID)   //删除指纹                 校验和在2字节的页码处应分高低字节相加
 573          {
 574   1         uchar i,ID1,ID2;
 575   1         SBUF=0xef;
 576   1         while(TI==0);
 577   1         TI=0;
 578   1         SBUF=0X01;
 579   1         while(TI==0);
 580   1         TI=0;
 581   1              
 582   1         SBUF=0XFF;
 583   1         while(TI==0);
 584   1         TI=0;
 585   1         SBUF=0XFF;
 586   1         while(TI==0);
 587   1         TI=1;
 588   1         SBUF=0XFF;
 589   1         while(TI==0);
 590   1         TI=0;
 591   1         SBUF=0XFF;
 592   1         while(TI==0);
 593   1         TI=0;
 594   1              
 595   1         SBUF=0X01;
 596   1         while(TI==0);
 597   1         TI=0;
 598   1              
 599   1         SBUF=0X00;
 600   1         while(TI==0);
 601   1         TI=0;
 602   1         SBUF=0X07;
 603   1         while(TI==0);
 604   1         TI=0;
 605   1              
 606   1         SBUF=0X0c;
 607   1         while(TI==0);
 608   1         TI=0;
 609   1              
 610   1         ID1=pageID;ID2=pageID>>8;
 611   1         SBUF=ID2;
 612   1         while(TI==0);
 613   1         TI=0;
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 11  

 614   1         SBUF=ID1;
 615   1         while(TI==0);
 616   1         TI=0;
 617   1              
 618   1         SBUF=0X00;
 619   1         while(TI==0);
 620   1         TI=0;
 621   1         SBUF=1;
 622   1         while(TI==0);
 623   1         TI=0;
 624   1              
 625   1         summaf=0x15+ID1+ID2;
 626   1         sum[0]=summaf;
 627   1         sum[1]=summaf>>8;
 628   1         SBUF=sum[1];
 629   1         while(TI==0);
 630   1         TI=0;
 631   1         SBUF=sum[0];
 632   1         while(TI==0);
 633   1         TI=0;
 634   1              
 635   1         for(i=0;i<9;i++)
 636   1         {
 637   2          while(RI==0);
 638   2          RI=0;}
 639   1         while(RI==0);
 640   1         RI=0;
 641   1         querenma=SBUF;
 642   1         while(RI==0);
 643   1         RI=0;
 644   1         sum[1]=SBUF;
 645   1         while(RI==0);
 646   1         RI=0;
 647   1         sum[0]=SBUF;
 648   1         summas=(sum[1]<<8)+sum[0];                                                                    
 649   1      }
 650              
 651          void SFG_identify()                             //自动验证指纹     录图像+生成特征+搜索
 652          {
 653   1         uchar i,ID1,ID2; 
 654   1         SBUF=0xef;
 655   1         while(TI==0);
 656   1         TI=0;
 657   1         SBUF=0X01;
 658   1         while(TI==0);
 659   1         TI=0;
 660   1              
 661   1         SBUF=0XFF;
 662   1         while(TI==0);
 663   1         TI=0;
 664   1         SBUF=0XFF;
 665   1         while(TI==0);
 666   1         TI=0;
 667   1         SBUF=0XFF;
 668   1         while(TI==0);
 669   1         TI=0;
 670   1         SBUF=0XFF;
 671   1         while(TI==0);
 672   1         TI=1;
 673   1              
 674   1         SBUF=0X01;
 675   1         while(TI==0);
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 12  

 676   1         TI=0;
 677   1              
 678   1         SBUF=0X00;
 679   1         while(TI==0);
 680   1         TI=0;
 681   1         SBUF=0X03;
 682   1         while(TI==0);
 683   1         TI=0;
 684   1              
 685   1         SBUF=0X11;
 686   1         while(TI==0);
 687   1         TI=0;
 688   1                 
 689   1         SBUF=0X00;
 690   1         while(TI==0);
 691   1         TI=0;
 692   1         summaf=0x15;
 693   1         SBUF=summaf;    //校验和
 694   1         while(TI==0);
 695   1         TI=0;
 696   1              
 697   1         for(i=0;i<9;i++)
 698   1         {
 699   2          while(RI==0);
 700   2          RI=0;}
 701   1         while(RI==0);
 702   1         RI=0;
 703   1         querenma=SBUF;
 704   1         while(RI==0);
 705   1         RI=0;
 706   1         ID1=SBUF;
 707   1         while(RI==0);
 708   1         RI=0;
 709   1         ID2=SBUF;
 710   1              
 711   1         while(RI==0);
 712   1         RI=0;
 713   1         while(RI==0);
 714   1         RI=0;                          //得分
 715   1              
 716   1         while(RI==0);
 717   1         RI=0;
 718   1         sum[1]=SBUF;
 719   1         while(RI==0);
 720   1         RI=0;
 721   1         sum[0]=SBUF;
 722   1         summas=(sum[1]>>8)+sum[0];                                                                    
 723   1         //PageID=ID1;
 724   1         PageID=(ID1>>8)+ID2;
 725   1      }
 726          void shuazhiwen()
 727          {
 728   1          uchar IDs1,IDs2,IDs3;        
 729   1              LcmClearTXT();
 730   1              PutStr(1,1,"请按手指开锁");
 731   1      //      ks2=0;      
 732   1              SFG_identify();
 733   1              while(querenma==2)
 734   1              SFG_identify(); 
 735   1              if(querenma==0)
 736   1         {
 737   2                      LcmClearTXT();
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 13  

 738   2                      PutStr(1,2,"门已打开"); 
 739   2                      IDs1=PageID/100;
 740   2                      IDs2=PageID/10%10;
 741   2                      IDs3=PageID%10;
 742   2                      PutStr(2,1,"编号为:");
 743   2                      WriteCommand(0x8D);             //指定第三行显示位置
 744   2                      WriteData(0x30+IDs1);
 745   2                      WriteData(0x30+IDs2);
 746   2                      WriteData(0x30+IDs3);
 747   2                      jidianqi=0;
 748   2                      delay(2500); 
 749   2                      jidianqi=1;     
 750   2              }
 751   1              else if(querenma==9)
 752   1                      {
 753   2                              LcmClearTXT();
 754   2                              PutStr(1,1,"没搜索到指纹");
 755   2                              PutStr(2,1,"请重新按手指");
 756   2      //                      ks1=0;
 757   2                      }
 758   1                      else 
 759   1                      {
 760   2                              LcmClearTXT();
 761   2                              PutStr(1,1,"接收包出错");
 762   2                      }
 763   1                      delay(2000);
 764   1         //    while(Keycan()==0);
 765   1      }
 766          void addfinger()
 767          {
 768   1              uchar IDa1,IDa2,IDa3;
 769   1              LcmClearTXT();
 770   1              PutStr(1,2,"请按手指"); 
 771   1      //      ks2=0;   
 772   1              SFG_getimage();
 773   1              while(querenma!=0)
 774   1              SFG_getimage();
 775   1              SFG_genchar(buffer1ID);
 776   1              UART_Init();
 777   1              SFG_fastsearch(buffer1ID);
 778   1              while(querenma==1)
 779   1              SFG_fastsearch(buffer1ID);
 780   1              if(querenma==0)
 781   1              {
 782   2                      LcmClearTXT();
 783   2                      PutStr(1,1,"该指纹已存储");
 784   2              
 785   2                      PutStr(3,0,"  按任意键继续"); 
 786   2                  while(Keycan()==0);
 787   2              }
 788   1              else if(querenma==9)
 789   1                      {
 790   2                              LcmClearTXT();
 791   2                              PutStr(1,1,"请再次按手指");
 792   2      //                      ks4=0;
 793   2                              SFG_enroll();
 794   2                              while(querenma==2)
 795   2                              SFG_enroll();
 796   2                              LcmClearTXT();
 797   2                              if(querenma==0)
 798   2                              { 
 799   3                                      IDa1=PageID/100;IDa2=PageID/10%10;IDa3=PageID%10;
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 14  

 800   3                                      PutStr(1,1,"指纹采集成功");
 801   3      //                                      ks5=0;
 802   3                                      PutStr(2,1,"编号为:");
 803   3                                      WriteCommand(0x8D); 
 804   3                                      WriteData(0x30+IDa1);WriteData(0x30+IDa2);WriteData(0x30+IDa3);
 805   3                              }
 806   2                      else if(querenma!=0)
 807   2                              {
 808   3                                      PutStr(1,1,"指纹采集失败");
 809   3                                      PutStr(2,1,"请重新操作");
 810   3                              }
 811   2                      PutStr(3,0,"  按任意键继续"); 
 812   2                  while(Keycan()==0);
 813   2                      }
 814   1              LcmClearTXT();
 815   1      }
 816          void deletfinger()
 817          {
 818   1              uchar i,j=0;
 819   1              LcmClearTXT();
 820   1              PutStr(1,0,"输入删去的指纹号");
 821   1              for(i=0;i<5;i++)dz[i]=0;        
 822   1                 Key=Keycan();
 823   1                 while(Key!=queren)
 824   1                 {
 825   2                   Key=Keycan();
 826   2                   KeyDeal(Key);
 827   2                   delay(30);                                                       //按键有抖动@@@
 828   2                   if(Key==0)K=10;
 829   2                   if((K>=0)&&(K<=9))
 830   2                   {
 831   3                    dz[j]=K;
 832   3                        if(j<3)
 833   3                        {     
 834   4                                      WriteCommand(0x88+j);           //指定第三行显示位置
 835   4                                      WriteData(0x30+dz[j]);  
 836   4                        }
 837   3                    ++j;
 838   3                        if(j==4)
 839   3                    j=3;                                                                                                 //@@#yinhuang
 840   3                   }   //显示LCD12864并行显示 
 841   2                       if(K==34)              //按了删除键
 842   2                        {
 843   3                          if(j==0)
 844   3                              {
 845   4                                      WriteCommand(0x88);             //指定第三行显示位置
 846   4                                      WriteData(0x20);
 847   4                              }
 848   3                              else
 849   3                              {
 850   4                                      --j;
 851   4                                      WriteCommand(0x88+j);       //指定第三行显示位置
 852   4                                      WriteData(0x20);
 853   4                              }
 854   3                      }
 855   2              }
 856   1              if(j>=2)
 857   1              PageID=dz[2]+dz[1]*10+dz[0]*100;
 858   1              if(j==1)
 859   1              PageID=dz[1]+dz[0]*10;
 860   1              if(j==0)
 861   1              PageID=dz[0];
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 15  

 862   1              SFG_deletchar(PageID);
 863   1              if(querenma==1)
 864   1              {
 865   2                      LcmClearTXT();
 866   2                      PutStr(1,1,"删去指纹号成功！"); 
 867   2              }
 868   1              else
 869   1              {
 870   2                      LcmClearTXT();
 871   2                      PutStr(1,2,"删去指纹号失败！");  
 872   2              }
 873   1              PutStr(2,0,"  按任意键继续"); 
 874   1              while(Keycan()==0);
 875   1              LcmClearTXT();
 876   1      }
 877                  
 878          void gaimima()
 879          {
 880   1              uchar i,j=0,mima1[4],mima2[4];
 881   1              uchar k,temp;
 882   1              LcmClearTXT();
 883   1              PutStr(1,1,"请输入新密码");
 884   1      //      ks7=0;
 885   1              for(i=0;i<6;i++)mima1[i]=0;                                                                     
 886   1                 Key=Keycan();
 887   1            while(Key!=queren)
 888   1                 {
 889   2                   Key=Keycan();
 890   2                   KeyDeal(Key);
 891   2                   delay(30);                                                       
 892   2                   if(Key==0)K=10;
 893   2                   if((K>=0)&&(K<=9))
 894   2                   {
 895   3                    mima1[j]=K;
 896   3                        if(j<6)
 897   3                        {     
 898   4                                      WriteCommand(0x89+j);           //指定第三行显示位置
 899   4                                      WriteData(0x0f);        
 900   4                        }
 901   3                    ++j;
 902   3                        if(j==7)
 903   3                    j=6;                                                                                                 //@@#yinhuang
 904   3                   }   //显示LCD12864并行显示 
 905   2                       if(K==34)              //按了删除键
 906   2                        {
 907   3                          if(j==0)
 908   3                              {
 909   4                                      WriteCommand(0x89);             //指定第三行显示位置
 910   4                                      WriteData(0x20);
 911   4                              }
 912   3                              else
 913   3                              {
 914   4                                      --j;
 915   4                                      WriteCommand(0x89+j);       //指定第三行显示位置
 916   4                                      WriteData(0x40);
 917   4                              }
 918   3                      }
 919   2              }
 920   1              LcmClearTXT();
 921   1              LcmClearTXT();
 922   1              j=0;
 923   1              PutStr(1,0,"请再次输入新密码");
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 16  

 924   1      //      ks8=0;
 925   1              for(i=0;i<6;i++)mima2[i]=0;                                                                     
 926   1                 Key=Keycan();
 927   1            while(Key!=queren)
 928   1                 {
 929   2                   Key=Keycan();
 930   2                   KeyDeal(Key);
 931   2                   delay(30);                                                       
 932   2                   if(Key==0)K=10;
 933   2                   if((K>=0)&&(K<=9))
 934   2                   {
 935   3                    mima2[j]=K;
 936   3                        if(j<6)
 937   3                        {             
 938   4                                      WriteCommand(0x89+j);           //指定第三行显示位置
 939   4                                      WriteData(0x0f);        
 940   4                        }
 941   3                    ++j;
 942   3                        if(j==7)
 943   3                    j=6;                                                                                                 //@@#yinhuang
 944   3                   }   //显示LCD12864并行显示 
 945   2                       if(K==34)              //按了删除键
 946   2                        {
 947   3                          if(j==0)
 948   3                              {
 949   4                                      WriteCommand(0x89);             //指定第三行显示位置
 950   4                                      WriteData(0x20);
 951   4                              }
 952   3                              else
 953   3                              {
 954   4                                      --j;
 955   4                                      WriteCommand(0x89+j);       //指定第三行显示位置
 956   4                                      WriteData(0x20);
 957   4                              }
 958   3                      }
 959   2              }
 960   1              LcmClearTXT();
 961   1              if((mima1[0]==mima2[0])&&(mima1[1]==mima2[1])&&(mima1[2]==mima2[2])&&(mima1[3]==mima2[3])&&(mima1[4]==mim
             -a2[4])&&(mima1[5]==mima2[5]))
 962   1              {
 963   2                      for(i=0;i<6;i++)
 964   2                      mimaID[i]=mima1[i];
 965   2                      /////////////////////////////////////////////////////
 966   2                      for(i=0;i<6;i++)           //密码限制在6位以内
 967   2                      {
 968   3                              UserPassword[i]=mima1[i]+0x30;                                  
 969   3                      }
 970   2                      temp=(Member-1)*100;    
 971   2                      delayms(5);
 972   2                      for(k=1;k<6;k++)
 973   2                      {
 974   3                              x24c02_write(temp,UserPassword[k]);
 975   3                              delayms(10);
 976   3                              temp++;
 977   3                      }  
 978   2                      //////////////////////////////////////////////////////
 979   2                      PutStr(0,1,"密码修改成功");
 980   2      //              ks10=0; 
 981   2                      PutStr(3,0,"  按任意键继续");
 982   2                      while(Keycan()==0);
 983   2              }
 984   1              else
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 17  

 985   1              {
 986   2                      PutStr(0,0,"  密码修改失败  ");
 987   2                      PutStr(1,0,"两次输入的密码不"); 
 988   2                      PutStr(2,0,"一致，请重新操作");
 989   2      //              ks9=0;       
 990   2                      PutStr(3,0,"  按任意键继续"); 
 991   2                      while(Keycan()==0);
 992   2              }
 993   1              LcmClearTXT();
 994   1      }
 995          
 996          
 997          void zhu()
 998          {        
 999   1          LcmClearTXT();
1000   1              PutStr(1,2,"门已打开");
1001   1              jidianqi=0;
1002   1              delay(2500); 
1003   1              jidianqi=1;
1004   1              PutStr(3,0,"  按任意键继续");
1005   1              while(Keycan()==0);
1006   1      }
1007          
1008          
1009          void guanliyuan()
1010          { uchar i,j=0,x=1;
1011   1              uchar Right_flag;
1012   1           LcmClearTXT();
1013   1                      PutStr(1,1,"请输入密码：");     
1014   1                 for(i=0;i<6;i++)mima[i]=0;                                                                   
1015   1                 Key=Keycan();
1016   1            while(Key!=queren)
1017   1                 {
1018   2                   Key=Keycan();
1019   2                   KeyDeal(Key);
1020   2                   delay(30);                                                       
1021   2                   if(Key==0)K=10;
1022   2                   if((K>=0)&&(K<=9))
1023   2                   {
1024   3                    mima[j]=K;
1025   3      
1026   3                        if(j<6)
1027   3                        {     
1028   4                         WriteCommand(0x89+j);                //指定第三行显示位置
1029   4                     WriteData(0x0f); 
1030   4      
1031   4                        }
1032   3                    ++j;
1033   3                        if(j==7)
1034   3                    j=6;                                                                                                
1035   3                   }   //显示LCD12864并行显示 
1036   2                       if(K==34)              //按了删除键
1037   2                        {
1038   3                          if(j==0)
1039   3                              {
1040   4                            WriteCommand(0x89);               //指定第三行显示位置
1041   4                        WriteData(0x20);
1042   4                              }
1043   3                              else
1044   3                              {
1045   4                                --j;
1046   4                            WriteCommand(0x89+j);         //指定第三行显示位置
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 18  

1047   4                        WriteData(0x20);
1048   4                              }
1049   3                        }
1050   2                 }
1051   1          LcmClearTXT();
1052   1      
1053   1      
1054   1                for(i=0;i<6;i++)
1055   1               {
1056   2                  UserPassword[i]=mima[i]+0x30;
1057   2              
1058   2                } 
1059   1               if(j==6){Right_flag=PassWord_Chack(); }
1060   1                if (Right_flag==1)
1061   1               {
1062   2                         Right_flag=0;
1063   2      
1064   2           while(Keycan()!=tuichu)
1065   2            {  
1066   3                      PutStr(0,0,"按键1 : 增加指纹"); 
1067   3                      PutStr(1,0,"按键2 : 删去指纹");
1068   3                      PutStr(2,0,"按键3 : 手动开锁");
1069   3                      PutStr(3,0,"按键4 : 修改密码");
1070   3                      KeyDeal(Keycan());  
1071   3                  switch(K)
1072   3                  {
1073   4                   case 1:    addfinger();K=8; break;
1074   4                   case 2:    deletfinger();    break;
1075   4                       case 3:         zhu(); K=6;  break;
1076   4                       case 4:    gaimima();        break;
1077   4                   default: break;
1078   4                  }
1079   3            }
1080   2           }
1081   1          else
1082   1          {
1083   2      
1084   2                      PutStr(1,2,"密码错误");
1085   2                      PutStr(2,0,"  请重新操作！");
1086   2      //              ks9=0; 
1087   2                      PutStr(3,0,"  按任意键继续"); 
1088   2                   while(Keycan()==0);
1089   2          }
1090   1        Key=0;
1091   1        LcmClearTXT();
1092   1      }
1093          
1094          void fan()
1095          
1096          {
1097   1      //      PutStr(1,2,"请先按键");
1098   1      //      PutStr(2,2,"再刷指纹");
1099   1              PutStr(0,2,"欢迎使用");
1100   1              PutStr(1,1,"指纹门禁系统");
1101   1              PutStr(3,1,"请按手指开锁");
1102   1      //      ks2=0;
1103   1        Key=Keycan();
1104   1      if(k2==1)               //指纹刷机
1105   1        {
1106   2              LcmClearTXT();
1107   2              shuazhiwen();
1108   2              LcmClearTXT();
C51 COMPILER V9.01   _肝泼__胨_                                                            05/03/2018 21:45:27 PAGE 19  

1109   2        }
1110   1        if(Key==0x81)                 //管理员操作
1111   1        {
1112   2              LcmClearTXT();
1113   2              guanliyuan();
1114   2          LcmClearTXT();
1115   2        }
1116   1      
1117   1      }       
1118               
1119          void main()
1120          {       
1121   1      
1122   1      //PSB=0;
1123   1              UART_Init();       //串口初始化           
1124   1              x24c02_init();     //24C02初始化
1125   1              LcmInit();             //LCD12864初始化                                                                                            
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                 
1126   1              LcmClearTXT();     //LCD12864清屏       
1127   1              while(1) 
1128   1                      { 
1129   2                              fan();
1130   2                              delay(100);               
1131   2                      }       
1132   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3459    ----
   CONSTANT SIZE    =    432    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     42      33
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
